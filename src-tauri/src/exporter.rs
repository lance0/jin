use std::collections::HashSet;
use std::fs;
use std::path::Path;

use crate::types::{InferredType, NormalizedEntry};

pub fn export_env_example(root_path: &str, entries: &[NormalizedEntry]) -> Result<String, String> {
    // Get unique keys sorted alphabetically
    let mut unique_keys: Vec<String> = entries
        .iter()
        .map(|e| e.key.clone())
        .collect::<HashSet<_>>()
        .into_iter()
        .collect();
    unique_keys.sort();

    // Create a map of key -> entry for type hints
    let key_entry_map: std::collections::HashMap<String, &NormalizedEntry> = entries
        .iter()
        .map(|e| (e.key.clone(), e))
        .collect();

    // Generate .env.example content
    let mut lines = Vec::new();
    lines.push("# Generated by Jin - The Config Whisperer".to_string());
    lines.push(format!("# Total keys: {}", unique_keys.len()));
    lines.push("".to_string());

    for key in unique_keys {
        if let Some(entry) = key_entry_map.get(&key) {
            // Add type hint as comment
            let type_hint = match &entry.inferred_type {
                InferredType::String => "string",
                InferredType::Number => "number",
                InferredType::Boolean => "boolean",
                InferredType::Null => "null",
                InferredType::Unknown => "unknown",
            };

            lines.push(format!("# Type: {}", type_hint));

            // Add secret warning if applicable
            if entry.is_secret_guess.unwrap_or(false) {
                lines.push("# ⚠️ Sensitive value - keep secure".to_string());
            }

            // Add the key with empty value
            lines.push(format!("{}=", key));
            lines.push("".to_string());
        }
    }

    let content = lines.join("\n");

    // Write to file
    let output_path = Path::new(root_path).join(".env.example");
    fs::write(&output_path, &content).map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(output_path.to_string_lossy().to_string())
}
