use std::collections::{HashMap, HashSet};
use std::path::Path;

use crate::types::{ExportFormat, InferredType, NormalizedEntry};

pub async fn export_env_example(output_path: &str, entries: &[NormalizedEntry], format: ExportFormat) -> Result<String, String> {
    // Get unique keys sorted alphabetically
    let mut unique_keys: Vec<String> = entries
        .iter()
        .map(|e| e.key.clone())
        .collect::<HashSet<_>>()
        .into_iter()
        .collect();
    unique_keys.sort();

    // Create a map of key -> entry for metadata
    let key_entry_map: HashMap<String, &NormalizedEntry> = entries
        .iter()
        .map(|e| (e.key.clone(), e))
        .collect();

    let content = match format {
        ExportFormat::Env => generate_env_format(&unique_keys, &key_entry_map),
        ExportFormat::Json => generate_json_format(&unique_keys, &key_entry_map)?,
        ExportFormat::Yaml => generate_yaml_format(&unique_keys, &key_entry_map)?,
    };

    // Write to file
    let path = Path::new(output_path);
    tokio::fs::write(&path, &content).await.map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(path.to_string_lossy().to_string())
}

fn generate_env_format(unique_keys: &[String], key_entry_map: &HashMap<String, &NormalizedEntry>) -> String {
    let mut lines = Vec::new();
    lines.push("# Generated by Jin - The Config Whisperer".to_string());
    lines.push(format!("# Total keys: {}", unique_keys.len()));
    lines.push("".to_string());

    for key in unique_keys {
        if let Some(entry) = key_entry_map.get(key) {
            // Add type hint as comment
            let type_hint = match &entry.inferred_type {
                InferredType::String => "string",
                InferredType::Number => "number",
                InferredType::Boolean => "boolean",
                InferredType::Null => "null",
                InferredType::Unknown => "unknown",
            };

            lines.push(format!("# Type: {}", type_hint));

            // Add secret warning if applicable
            if entry.is_secret_guess.unwrap_or(false) {
                lines.push("# ⚠️ Sensitive value - keep secure".to_string());
            }

            // Add the key with empty value
            lines.push(format!("{}=", key));
            lines.push("".to_string());
        }
    }

    lines.join("\n")
}

fn generate_json_format(unique_keys: &[String], key_entry_map: &HashMap<String, &NormalizedEntry>) -> Result<String, String> {
    let mut config_map = serde_json::Map::new();

    for key in unique_keys {
        if let Some(entry) = key_entry_map.get(key) {
            let mut metadata = serde_json::Map::new();
            metadata.insert("value".to_string(), serde_json::Value::String("".to_string()));

            let type_str = match &entry.inferred_type {
                InferredType::String => "string",
                InferredType::Number => "number",
                InferredType::Boolean => "boolean",
                InferredType::Null => "null",
                InferredType::Unknown => "unknown",
            };
            metadata.insert("type".to_string(), serde_json::Value::String(type_str.to_string()));

            if entry.is_secret_guess.unwrap_or(false) {
                metadata.insert("sensitive".to_string(), serde_json::Value::Bool(true));
            }

            config_map.insert(key.clone(), serde_json::Value::Object(metadata));
        }
    }

    let root = serde_json::json!({
        "_meta": {
            "generator": "Jin - The Config Whisperer",
            "totalKeys": unique_keys.len()
        },
        "config": config_map
    });

    serde_json::to_string_pretty(&root).map_err(|e| format!("JSON serialization error: {}", e))
}

fn generate_yaml_format(unique_keys: &[String], key_entry_map: &HashMap<String, &NormalizedEntry>) -> Result<String, String> {
    let mut config_map = serde_yaml::Mapping::new();

    for key in unique_keys {
        if let Some(entry) = key_entry_map.get(key) {
            let mut metadata = serde_yaml::Mapping::new();
            metadata.insert(
                serde_yaml::Value::String("value".to_string()),
                serde_yaml::Value::String("".to_string())
            );

            let type_str = match &entry.inferred_type {
                InferredType::String => "string",
                InferredType::Number => "number",
                InferredType::Boolean => "boolean",
                InferredType::Null => "null",
                InferredType::Unknown => "unknown",
            };
            metadata.insert(
                serde_yaml::Value::String("type".to_string()),
                serde_yaml::Value::String(type_str.to_string())
            );

            if entry.is_secret_guess.unwrap_or(false) {
                metadata.insert(
                    serde_yaml::Value::String("sensitive".to_string()),
                    serde_yaml::Value::Bool(true)
                );
            }

            config_map.insert(
                serde_yaml::Value::String(key.clone()),
                serde_yaml::Value::Mapping(metadata)
            );
        }
    }

    let mut meta = serde_yaml::Mapping::new();
    meta.insert(
        serde_yaml::Value::String("generator".to_string()),
        serde_yaml::Value::String("Jin - The Config Whisperer".to_string())
    );
    meta.insert(
        serde_yaml::Value::String("totalKeys".to_string()),
        serde_yaml::Value::Number(unique_keys.len().into())
    );

    let mut root = serde_yaml::Mapping::new();
    root.insert(
        serde_yaml::Value::String("_meta".to_string()),
        serde_yaml::Value::Mapping(meta)
    );
    root.insert(
        serde_yaml::Value::String("config".to_string()),
        serde_yaml::Value::Mapping(config_map)
    );

    serde_yaml::to_string(&root).map_err(|e| format!("YAML serialization error: {}", e))
}
